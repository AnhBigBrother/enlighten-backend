// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO
  users (
    "id",
    "email",
    "name",
    "password",
    "image",
    "refresh_token",
    "created_at",
    "updated_at"
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING
  id, email, name, password, image, refresh_token, created_at, updated_at, bio
`

type CreateUserParams struct {
	ID           pgtype.UUID      `json:"id"`
	Email        string           `json:"email"`
	Name         string           `json:"name"`
	Password     string           `json:"password"`
	Image        pgtype.Text      `json:"image"`
	RefreshToken pgtype.Text      `json:"refresh_token"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Password,
		arg.Image,
		arg.RefreshToken,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Password,
		&i.Image,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const deleteUserInfo = `-- name: DeleteUserInfo :exec
DELETE FROM users
WHERE
  email = $1
`

func (q *Queries) DeleteUserInfo(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUserInfo, email)
	return err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT
  id, email, name, password, image, refresh_token, created_at, updated_at, bio
FROM
  users
WHERE
  email = $1
LIMIT
  1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Password,
		&i.Image,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const getTopAuthor = `-- name: GetTopAuthor :many
WITH
  count_followers AS (
    SELECT
      uf.author_id,
      COUNT(id) AS followers
    FROM
      user_follows uf
    GROUP BY
      uf.author_id
  ),
  authors AS (
    SELECT
      p.author_id,
      COUNT(id) AS total_posts,
      SUM(up_voted) AS total_upvoted
    FROM
      posts p
    GROUP BY
      p.author_id
  )
SELECT
  u.id,
  u.name,
  u.email,
  u.image,
  CASE
    WHEN a.total_posts IS NULL THEN 0
    ELSE a.total_posts
  END::INTEGER AS total_posts,
  CASE
    WHEN a.total_upvoted IS NULL THEN 0
    ELSE a.total_upvoted
  END::INTEGER AS total_upvoted,
  CASE
    WHEN cf.followers IS NULL THEN 0
    ELSE cf.followers
  END::INTEGER AS total_follower
FROM
  users u
  LEFT JOIN authors a ON u.id = a.author_id
  LEFT JOIN count_followers cf ON u.id = cf.author_id
ORDER BY
  total_upvoted DESC,
  total_follower DESC,
  total_posts DESC
LIMIT
  $1
OFFSET
  $2
`

type GetTopAuthorParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetTopAuthorRow struct {
	ID            pgtype.UUID `json:"id"`
	Name          string      `json:"name"`
	Email         string      `json:"email"`
	Image         pgtype.Text `json:"image"`
	TotalPosts    int32       `json:"total_posts"`
	TotalUpvoted  int32       `json:"total_upvoted"`
	TotalFollower int32       `json:"total_follower"`
}

func (q *Queries) GetTopAuthor(ctx context.Context, arg GetTopAuthorParams) ([]GetTopAuthorRow, error) {
	rows, err := q.db.Query(ctx, getTopAuthor, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopAuthorRow{}
	for rows.Next() {
		var i GetTopAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Image,
			&i.TotalPosts,
			&i.TotalUpvoted,
			&i.TotalFollower,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserHotPosts = `-- name: GetUserHotPosts :many
SELECT
  p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
  u.name AS author_name,
  u.email AS author_email,
  u.image AS author_image,
  p.up_voted + p.down_voted + p.comments_count AS total_interactions
FROM
  posts p
  INNER JOIN (
    SELECT
      id, email, name, password, image, refresh_token, created_at, updated_at, bio
    FROM
      users
    WHERE
      users.id = $1
  ) AS u ON p.author_id = u.id
ORDER BY
  total_interactions DESC
LIMIT
  $2
OFFSET
  $3
`

type GetUserHotPostsParams struct {
	ID     pgtype.UUID `json:"id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserHotPostsRow struct {
	ID                pgtype.UUID      `json:"id"`
	Title             string           `json:"title"`
	Content           string           `json:"content"`
	AuthorID          pgtype.UUID      `json:"author_id"`
	UpVoted           int32            `json:"up_voted"`
	DownVoted         int32            `json:"down_voted"`
	CommentsCount     int32            `json:"comments_count"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	AuthorName        string           `json:"author_name"`
	AuthorEmail       string           `json:"author_email"`
	AuthorImage       pgtype.Text      `json:"author_image"`
	TotalInteractions int32            `json:"total_interactions"`
}

func (q *Queries) GetUserHotPosts(ctx context.Context, arg GetUserHotPostsParams) ([]GetUserHotPostsRow, error) {
	rows, err := q.db.Query(ctx, getUserHotPosts, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserHotPostsRow{}
	for rows.Next() {
		var i GetUserHotPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.AuthorImage,
			&i.TotalInteractions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNewPosts = `-- name: GetUserNewPosts :many
SELECT
  p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
  u.name AS author_name,
  u.email AS author_email,
  u.image AS author_image
FROM
  posts p
  INNER JOIN (
    SELECT
      id, email, name, password, image, refresh_token, created_at, updated_at, bio
    FROM
      users
    WHERE
      users.id = $1
  ) AS u ON p.author_id = u.id
ORDER BY
  p.created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type GetUserNewPostsParams struct {
	ID     pgtype.UUID `json:"id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserNewPostsRow struct {
	ID            pgtype.UUID      `json:"id"`
	Title         string           `json:"title"`
	Content       string           `json:"content"`
	AuthorID      pgtype.UUID      `json:"author_id"`
	UpVoted       int32            `json:"up_voted"`
	DownVoted     int32            `json:"down_voted"`
	CommentsCount int32            `json:"comments_count"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	AuthorName    string           `json:"author_name"`
	AuthorEmail   string           `json:"author_email"`
	AuthorImage   pgtype.Text      `json:"author_image"`
}

func (q *Queries) GetUserNewPosts(ctx context.Context, arg GetUserNewPostsParams) ([]GetUserNewPostsRow, error) {
	rows, err := q.db.Query(ctx, getUserNewPosts, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserNewPostsRow{}
	for rows.Next() {
		var i GetUserNewPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.AuthorImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOverview = `-- name: GetUserOverview :one
WITH
  total_interactions AS (
    SELECT
      u.id,
      u.name,
      u.email,
      u.image,
      u.bio,
      u.created_at,
      u.updated_at,
      CASE
        WHEN a.total_posts IS NULL THEN 0
        ELSE a.total_posts
      END::INTEGER AS total_posts,
      CASE
        WHEN a.total_upvoted IS NULL THEN 0
        ELSE a.total_upvoted
      END::INTEGER AS total_upvoted,
      CASE
        WHEN a.total_downvoted IS NULL THEN 0
        ELSE a.total_downvoted
      END::INTEGER AS total_downvoted
    FROM
      (
        SELECT
          id, email, name, password, image, refresh_token, created_at, updated_at, bio
        FROM
          users u1
        WHERE
          u1.id = $1
      ) u
      LEFT JOIN (
        SELECT
          author_id,
          COUNT(*) AS total_posts,
          SUM(up_voted) AS total_upvoted,
          SUM(down_voted) AS total_downvoted
        FROM
          posts p
        WHERE
          p.author_id = $1
        GROUP BY
          p.author_id
      ) a ON u.id = a.author_id
  ),
  total_follows AS (
    SELECT
      author_id, follower, follower_id, following,
      CASE
        WHEN fr.author_id IS NULL THEN fg.follower_id
        ELSE fr.author_id
      END AS user_id
    FROM
      (
        SELECT
          author_id,
          COUNT(id) AS follower
        FROM
          user_follows f1
        WHERE
          f1.author_id = $1
        GROUP BY
          author_id
      ) fr
      FULL OUTER JOIN (
        SELECT
          follower_id,
          COUNT(id) AS "following"
        FROM
          user_follows f2
        WHERE
          f2.follower_id = $1
        GROUP BY
          f2.follower_id
      ) fg ON fr.author_id = fg.follower_id
  )
SELECT
  total_interactions.id, total_interactions.name, total_interactions.email, total_interactions.image, total_interactions.bio, total_interactions.created_at, total_interactions.updated_at, total_interactions.total_posts, total_interactions.total_upvoted, total_interactions.total_downvoted,
  CASE
    WHEN total_follows.follower IS NULL THEN 0
    ELSE total_follows.follower
  END::INTEGER AS follower,
  CASE
    WHEN total_follows.following IS NULL THEN 0
    ELSE total_follows.following
  END::INTEGER AS "following"
FROM
  total_interactions
  LEFT JOIN total_follows ON total_interactions.id = total_follows.user_id
`

type GetUserOverviewRow struct {
	ID             pgtype.UUID      `json:"id"`
	Name           string           `json:"name"`
	Email          string           `json:"email"`
	Image          pgtype.Text      `json:"image"`
	Bio            pgtype.Text      `json:"bio"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	TotalPosts     int32            `json:"total_posts"`
	TotalUpvoted   int32            `json:"total_upvoted"`
	TotalDownvoted int32            `json:"total_downvoted"`
	Follower       int32            `json:"follower"`
	Following      int32            `json:"following"`
}

func (q *Queries) GetUserOverview(ctx context.Context, id pgtype.UUID) (GetUserOverviewRow, error) {
	row := q.db.QueryRow(ctx, getUserOverview, id)
	var i GetUserOverviewRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalPosts,
		&i.TotalUpvoted,
		&i.TotalDownvoted,
		&i.Follower,
		&i.Following,
	)
	return i, err
}

const getUserTopPosts = `-- name: GetUserTopPosts :many
SELECT
  p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
  u.name AS author_name,
  u.email AS author_email,
  u.image AS author_image
FROM
  posts p
  INNER JOIN (
    SELECT
      id, email, name, password, image, refresh_token, created_at, updated_at, bio
    FROM
      users
    WHERE
      users.id = $1
  ) AS u ON p.author_id = u.id
ORDER BY
  p.up_voted DESC,
  p.down_voted ASC
LIMIT
  $2
OFFSET
  $3
`

type GetUserTopPostsParams struct {
	ID     pgtype.UUID `json:"id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserTopPostsRow struct {
	ID            pgtype.UUID      `json:"id"`
	Title         string           `json:"title"`
	Content       string           `json:"content"`
	AuthorID      pgtype.UUID      `json:"author_id"`
	UpVoted       int32            `json:"up_voted"`
	DownVoted     int32            `json:"down_voted"`
	CommentsCount int32            `json:"comments_count"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	AuthorName    string           `json:"author_name"`
	AuthorEmail   string           `json:"author_email"`
	AuthorImage   pgtype.Text      `json:"author_image"`
}

func (q *Queries) GetUserTopPosts(ctx context.Context, arg GetUserTopPostsParams) ([]GetUserTopPostsRow, error) {
	rows, err := q.db.Query(ctx, getUserTopPosts, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTopPostsRow{}
	for rows.Next() {
		var i GetUserTopPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.AuthorImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserInfo = `-- name: UpdateUserInfo :one
UPDATE users
SET
  "name" = $2,
  "password" = $3,
  "image" = $4,
  "bio" = $5,
  "updated_at" = $6
WHERE
  email = $1
RETURNING
  id, email, name, password, image, refresh_token, created_at, updated_at, bio
`

type UpdateUserInfoParams struct {
	Email     string           `json:"email"`
	Name      string           `json:"name"`
	Password  string           `json:"password"`
	Image     pgtype.Text      `json:"image"`
	Bio       pgtype.Text      `json:"bio"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateUserInfo(ctx context.Context, arg UpdateUserInfoParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserInfo,
		arg.Email,
		arg.Name,
		arg.Password,
		arg.Image,
		arg.Bio,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Password,
		&i.Image,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const updateUserRefreshToken = `-- name: UpdateUserRefreshToken :one
UPDATE users
SET
  refresh_token = $2
WHERE
  email = $1
RETURNING
  id, email, name, password, image, refresh_token, created_at, updated_at, bio
`

type UpdateUserRefreshTokenParams struct {
	Email        string      `json:"email"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

func (q *Queries) UpdateUserRefreshToken(ctx context.Context, arg UpdateUserRefreshTokenParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRefreshToken, arg.Email, arg.RefreshToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Password,
		&i.Image,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}
