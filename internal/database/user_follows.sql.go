// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_follows.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createFollows = `-- name: CreateFollows :exec
INSERT INTO
  user_follows ("id", "follower_id", "author_id", "created_at")
VALUES
  ($1, $2, $3, $4)
`

type CreateFollowsParams struct {
	ID         uuid.UUID
	FollowerID uuid.UUID
	AuthorID   uuid.UUID
	CreatedAt  time.Time
}

func (q *Queries) CreateFollows(ctx context.Context, arg CreateFollowsParams) error {
	_, err := q.db.ExecContext(ctx, createFollows,
		arg.ID,
		arg.FollowerID,
		arg.AuthorID,
		arg.CreatedAt,
	)
	return err
}

const deleteFollows = `-- name: DeleteFollows :exec
DELETE FROM user_follows
WHERE
  author_id = $1
  AND follower_id = $2
`

type DeleteFollowsParams struct {
	AuthorID   uuid.UUID
	FollowerID uuid.UUID
}

func (q *Queries) DeleteFollows(ctx context.Context, arg DeleteFollowsParams) error {
	_, err := q.db.ExecContext(ctx, deleteFollows, arg.AuthorID, arg.FollowerID)
	return err
}

const getFollowedAuthor = `-- name: GetFollowedAuthor :many
SELECT
  u.id,
  u.email,
  u.name,
  u.image
FROM
  (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows uf
    WHERE
      uf.follower_id = $1
  ) fu
  INNER JOIN users u ON fu.author_id = u.id
ORDER BY
  fu.created_at
LIMIT
  $2
OFFSET
  $3
`

type GetFollowedAuthorParams struct {
	FollowerID uuid.UUID
	Limit      int32
	Offset     int32
}

type GetFollowedAuthorRow struct {
	ID    uuid.UUID
	Email string
	Name  string
	Image sql.NullString
}

func (q *Queries) GetFollowedAuthor(ctx context.Context, arg GetFollowedAuthorParams) ([]GetFollowedAuthorRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowedAuthor, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowedAuthorRow
	for rows.Next() {
		var i GetFollowedAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowedPosts = `-- name: GetFollowedPosts :many
SELECT
  fa.author_email,
  fa.author_name,
  fa.author_image,
  p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at
FROM
  (
    SELECT
      u.id,
      u.name AS author_name,
      u.email AS author_email,
      u.image AS author_image
    FROM
      (
        SELECT
          id, follower_id, author_id, created_at
        FROM
          user_follows
        WHERE
          user_follows.follower_id = $1
      ) uf
      LEFT JOIN users u ON uf.author_id = u.id
  ) fa
  LEFT JOIN posts p ON fa.id = p.author_id
ORDER BY
  p.created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type GetFollowedPostsParams struct {
	FollowerID uuid.UUID
	Limit      int32
	Offset     int32
}

type GetFollowedPostsRow struct {
	AuthorEmail   sql.NullString
	AuthorName    sql.NullString
	AuthorImage   sql.NullString
	ID            uuid.NullUUID
	Title         sql.NullString
	Content       sql.NullString
	AuthorID      uuid.NullUUID
	UpVoted       sql.NullInt32
	DownVoted     sql.NullInt32
	CommentsCount sql.NullInt32
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
}

func (q *Queries) GetFollowedPosts(ctx context.Context, arg GetFollowedPostsParams) ([]GetFollowedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowedPostsRow
	for rows.Next() {
		var i GetFollowedPostsRow
		if err := rows.Scan(
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollows = `-- name: GetFollows :one
SELECT
  id, follower_id, author_id, created_at
FROM
  user_follows
WHERE
  follower_id = $1
  AND author_id = $2
`

type GetFollowsParams struct {
	FollowerID uuid.UUID
	AuthorID   uuid.UUID
}

func (q *Queries) GetFollows(ctx context.Context, arg GetFollowsParams) (UserFollow, error) {
	row := q.db.QueryRowContext(ctx, getFollows, arg.FollowerID, arg.AuthorID)
	var i UserFollow
	err := row.Scan(
		&i.ID,
		&i.FollowerID,
		&i.AuthorID,
		&i.CreatedAt,
	)
	return i, err
}

const getHotFollowedPosts = `-- name: GetHotFollowedPosts :many
SELECT
  ap.id, ap.title, ap.content, ap.author_id, ap.up_voted, ap.down_voted, ap.comments_count, ap.created_at, ap.updated_at, ap.author_email, ap.author_name, ap.author_image,
  ap.up_voted + ap.down_voted + ap.comments_count AS total_interactions,
  CASE
    WHEN uf.id IS NOT NULL THEN 'Followed'
    ELSE 'Recommend'
  END AS status
FROM
  (
    SELECT
      p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
      u.email AS author_email,
      u.name AS author_name,
      u.image AS author_image
    FROM
      posts p
      LEFT JOIN users u ON p.author_id = u.id
  ) ap
  LEFT JOIN (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows
    WHERE
      user_follows.follower_id = $1
  ) uf ON ap.author_id = uf.author_id
ORDER BY
  status ASC,
  total_interactions DESC
LIMIT
  $2
OFFSET
  $3
`

type GetHotFollowedPostsParams struct {
	FollowerID uuid.UUID
	Limit      int32
	Offset     int32
}

type GetHotFollowedPostsRow struct {
	ID                uuid.UUID
	Title             string
	Content           string
	AuthorID          uuid.UUID
	UpVoted           int32
	DownVoted         int32
	CommentsCount     int32
	CreatedAt         time.Time
	UpdatedAt         time.Time
	AuthorEmail       sql.NullString
	AuthorName        sql.NullString
	AuthorImage       sql.NullString
	TotalInteractions int32
	Status            string
}

func (q *Queries) GetHotFollowedPosts(ctx context.Context, arg GetHotFollowedPostsParams) ([]GetHotFollowedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getHotFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHotFollowedPostsRow
	for rows.Next() {
		var i GetHotFollowedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.TotalInteractions,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewFollowedPosts = `-- name: GetNewFollowedPosts :many
SELECT
  ap.id, ap.title, ap.content, ap.author_id, ap.up_voted, ap.down_voted, ap.comments_count, ap.created_at, ap.updated_at, ap.author_email, ap.author_name, ap.author_image,
  CASE
    WHEN uf.id IS NOT NULL THEN 'Followed'
    ELSE 'Recommend'
  END AS status
FROM
  (
    SELECT
      p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
      u.email AS author_email,
      u.name AS author_name,
      u.image AS author_image
    FROM
      posts p
      LEFT JOIN users u ON p.author_id = u.id
  ) ap
  LEFT JOIN (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows
    WHERE
      user_follows.follower_id = $1
  ) uf ON ap.author_id = uf.author_id
ORDER BY
  status ASC,
  ap.created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type GetNewFollowedPostsParams struct {
	FollowerID uuid.UUID
	Limit      int32
	Offset     int32
}

type GetNewFollowedPostsRow struct {
	ID            uuid.UUID
	Title         string
	Content       string
	AuthorID      uuid.UUID
	UpVoted       int32
	DownVoted     int32
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	AuthorEmail   sql.NullString
	AuthorName    sql.NullString
	AuthorImage   sql.NullString
	Status        string
}

func (q *Queries) GetNewFollowedPosts(ctx context.Context, arg GetNewFollowedPostsParams) ([]GetNewFollowedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNewFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNewFollowedPostsRow
	for rows.Next() {
		var i GetNewFollowedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopFollowedPosts = `-- name: GetTopFollowedPosts :many
SELECT
  ap.id, ap.title, ap.content, ap.author_id, ap.up_voted, ap.down_voted, ap.comments_count, ap.created_at, ap.updated_at, ap.author_email, ap.author_name, ap.author_image,
  CASE
    WHEN uf.id IS NOT NULL THEN 'Followed'
    ELSE 'Recommend'
  END AS status
FROM
  (
    SELECT
      p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
      u.email AS author_email,
      u.name AS author_name,
      u.image AS author_image
    FROM
      posts p
      LEFT JOIN users u ON p.author_id = u.id
  ) ap
  LEFT JOIN (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows
    WHERE
      user_follows.follower_id = $1
  ) uf ON ap.author_id = uf.author_id
ORDER BY
  status ASC,
  ap.up_voted DESC
LIMIT
  $2
OFFSET
  $3
`

type GetTopFollowedPostsParams struct {
	FollowerID uuid.UUID
	Limit      int32
	Offset     int32
}

type GetTopFollowedPostsRow struct {
	ID            uuid.UUID
	Title         string
	Content       string
	AuthorID      uuid.UUID
	UpVoted       int32
	DownVoted     int32
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	AuthorEmail   sql.NullString
	AuthorName    sql.NullString
	AuthorImage   sql.NullString
	Status        string
}

func (q *Queries) GetTopFollowedPosts(ctx context.Context, arg GetTopFollowedPostsParams) ([]GetTopFollowedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopFollowedPostsRow
	for rows.Next() {
		var i GetTopFollowedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
