// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_follows.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFollows = `-- name: CreateFollows :exec
INSERT INTO
  user_follows ("id", "follower_id", "author_id", "created_at")
VALUES
  ($1, $2, $3, $4)
`

type CreateFollowsParams struct {
	ID         pgtype.UUID      `json:"id"`
	FollowerID pgtype.UUID      `json:"follower_id"`
	AuthorID   pgtype.UUID      `json:"author_id"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateFollows(ctx context.Context, arg CreateFollowsParams) error {
	_, err := q.db.Exec(ctx, createFollows,
		arg.ID,
		arg.FollowerID,
		arg.AuthorID,
		arg.CreatedAt,
	)
	return err
}

const deleteFollows = `-- name: DeleteFollows :exec
DELETE FROM user_follows
WHERE
  author_id = $1
  AND follower_id = $2
`

type DeleteFollowsParams struct {
	AuthorID   pgtype.UUID `json:"author_id"`
	FollowerID pgtype.UUID `json:"follower_id"`
}

func (q *Queries) DeleteFollows(ctx context.Context, arg DeleteFollowsParams) error {
	_, err := q.db.Exec(ctx, deleteFollows, arg.AuthorID, arg.FollowerID)
	return err
}

const getFollowedAuthor = `-- name: GetFollowedAuthor :many
SELECT
  u.id,
  u.email,
  u.name,
  u.image
FROM
  (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows uf
    WHERE
      uf.follower_id = $1
  ) fu
  INNER JOIN users u ON fu.author_id = u.id
ORDER BY
  fu.created_at
LIMIT
  $2
OFFSET
  $3
`

type GetFollowedAuthorParams struct {
	FollowerID pgtype.UUID `json:"follower_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetFollowedAuthorRow struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
	Name  string      `json:"name"`
	Image pgtype.Text `json:"image"`
}

func (q *Queries) GetFollowedAuthor(ctx context.Context, arg GetFollowedAuthorParams) ([]GetFollowedAuthorRow, error) {
	rows, err := q.db.Query(ctx, getFollowedAuthor, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFollowedAuthorRow{}
	for rows.Next() {
		var i GetFollowedAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowedPosts = `-- name: GetFollowedPosts :many
SELECT
  fa.author_email,
  fa.author_name,
  fa.author_image,
  p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at
FROM
  (
    SELECT
      u.id,
      u.name AS author_name,
      u.email AS author_email,
      u.image AS author_image
    FROM
      (
        SELECT
          id, follower_id, author_id, created_at
        FROM
          user_follows
        WHERE
          user_follows.follower_id = $1
      ) uf
      LEFT JOIN users u ON uf.author_id = u.id
  ) fa
  LEFT JOIN posts p ON fa.id = p.author_id
ORDER BY
  p.created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type GetFollowedPostsParams struct {
	FollowerID pgtype.UUID `json:"follower_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetFollowedPostsRow struct {
	AuthorEmail   pgtype.Text      `json:"author_email"`
	AuthorName    pgtype.Text      `json:"author_name"`
	AuthorImage   pgtype.Text      `json:"author_image"`
	ID            pgtype.UUID      `json:"id"`
	Title         pgtype.Text      `json:"title"`
	Content       pgtype.Text      `json:"content"`
	AuthorID      pgtype.UUID      `json:"author_id"`
	UpVoted       pgtype.Int4      `json:"up_voted"`
	DownVoted     pgtype.Int4      `json:"down_voted"`
	CommentsCount pgtype.Int4      `json:"comments_count"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetFollowedPosts(ctx context.Context, arg GetFollowedPostsParams) ([]GetFollowedPostsRow, error) {
	rows, err := q.db.Query(ctx, getFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFollowedPostsRow{}
	for rows.Next() {
		var i GetFollowedPostsRow
		if err := rows.Scan(
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollows = `-- name: GetFollows :one
SELECT
  id, follower_id, author_id, created_at
FROM
  user_follows
WHERE
  follower_id = $1
  AND author_id = $2
`

type GetFollowsParams struct {
	FollowerID pgtype.UUID `json:"follower_id"`
	AuthorID   pgtype.UUID `json:"author_id"`
}

func (q *Queries) GetFollows(ctx context.Context, arg GetFollowsParams) (UserFollow, error) {
	row := q.db.QueryRow(ctx, getFollows, arg.FollowerID, arg.AuthorID)
	var i UserFollow
	err := row.Scan(
		&i.ID,
		&i.FollowerID,
		&i.AuthorID,
		&i.CreatedAt,
	)
	return i, err
}

const getHotFollowedPosts = `-- name: GetHotFollowedPosts :many
SELECT
  ap.id, ap.title, ap.content, ap.author_id, ap.up_voted, ap.down_voted, ap.comments_count, ap.created_at, ap.updated_at, ap.author_email, ap.author_name, ap.author_image,
  ap.up_voted + ap.down_voted + ap.comments_count AS total_interactions,
  CASE
    WHEN uf.id IS NOT NULL THEN 1
    ELSE 0
  END AS priority
FROM
  (
    SELECT
      p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
      u.email AS author_email,
      u.name AS author_name,
      u.image AS author_image
    FROM
      posts p
      LEFT JOIN users u ON p.author_id = u.id
  ) ap
  LEFT JOIN (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows
    WHERE
      user_follows.follower_id = $1
  ) uf ON ap.author_id = uf.author_id
ORDER BY
  priority DESC,
  total_interactions DESC
LIMIT
  $2
OFFSET
  $3
`

type GetHotFollowedPostsParams struct {
	FollowerID pgtype.UUID `json:"follower_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetHotFollowedPostsRow struct {
	ID                pgtype.UUID      `json:"id"`
	Title             string           `json:"title"`
	Content           string           `json:"content"`
	AuthorID          pgtype.UUID      `json:"author_id"`
	UpVoted           int32            `json:"up_voted"`
	DownVoted         int32            `json:"down_voted"`
	CommentsCount     int32            `json:"comments_count"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	AuthorEmail       pgtype.Text      `json:"author_email"`
	AuthorName        pgtype.Text      `json:"author_name"`
	AuthorImage       pgtype.Text      `json:"author_image"`
	TotalInteractions int32            `json:"total_interactions"`
	Priority          int32            `json:"priority"`
}

func (q *Queries) GetHotFollowedPosts(ctx context.Context, arg GetHotFollowedPostsParams) ([]GetHotFollowedPostsRow, error) {
	rows, err := q.db.Query(ctx, getHotFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHotFollowedPostsRow{}
	for rows.Next() {
		var i GetHotFollowedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.TotalInteractions,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewFollowedPosts = `-- name: GetNewFollowedPosts :many
SELECT
  ap.id, ap.title, ap.content, ap.author_id, ap.up_voted, ap.down_voted, ap.comments_count, ap.created_at, ap.updated_at, ap.author_email, ap.author_name, ap.author_image,
  CASE
    WHEN uf.id IS NOT NULL THEN 1
    ELSE 0
  END AS priority
FROM
  (
    SELECT
      p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
      u.email AS author_email,
      u.name AS author_name,
      u.image AS author_image
    FROM
      posts p
      LEFT JOIN users u ON p.author_id = u.id
  ) ap
  LEFT JOIN (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows f
    WHERE
      f.follower_id = $1
  ) uf ON ap.author_id = uf.author_id
ORDER BY
  priority DESC,
  ap.created_at DESC
LIMIT
  $2
OFFSET
  $3
`

type GetNewFollowedPostsParams struct {
	FollowerID pgtype.UUID `json:"follower_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetNewFollowedPostsRow struct {
	ID            pgtype.UUID      `json:"id"`
	Title         string           `json:"title"`
	Content       string           `json:"content"`
	AuthorID      pgtype.UUID      `json:"author_id"`
	UpVoted       int32            `json:"up_voted"`
	DownVoted     int32            `json:"down_voted"`
	CommentsCount int32            `json:"comments_count"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	AuthorEmail   pgtype.Text      `json:"author_email"`
	AuthorName    pgtype.Text      `json:"author_name"`
	AuthorImage   pgtype.Text      `json:"author_image"`
	Priority      int32            `json:"priority"`
}

func (q *Queries) GetNewFollowedPosts(ctx context.Context, arg GetNewFollowedPostsParams) ([]GetNewFollowedPostsRow, error) {
	rows, err := q.db.Query(ctx, getNewFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNewFollowedPostsRow{}
	for rows.Next() {
		var i GetNewFollowedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopFollowedPosts = `-- name: GetTopFollowedPosts :many
SELECT
  ap.id, ap.title, ap.content, ap.author_id, ap.up_voted, ap.down_voted, ap.comments_count, ap.created_at, ap.updated_at, ap.author_email, ap.author_name, ap.author_image,
  CASE
    WHEN uf.id IS NOT NULL THEN 1
    ELSE 0
  END AS priority
FROM
  (
    SELECT
      p.id, p.title, p.content, p.author_id, p.up_voted, p.down_voted, p.comments_count, p.created_at, p.updated_at,
      u.email AS author_email,
      u.name AS author_name,
      u.image AS author_image
    FROM
      posts p
      LEFT JOIN users u ON p.author_id = u.id
  ) ap
  LEFT JOIN (
    SELECT
      id, follower_id, author_id, created_at
    FROM
      user_follows
    WHERE
      user_follows.follower_id = $1
  ) uf ON ap.author_id = uf.author_id
ORDER BY
  priority DESC,
  ap.up_voted DESC
LIMIT
  $2
OFFSET
  $3
`

type GetTopFollowedPostsParams struct {
	FollowerID pgtype.UUID `json:"follower_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetTopFollowedPostsRow struct {
	ID            pgtype.UUID      `json:"id"`
	Title         string           `json:"title"`
	Content       string           `json:"content"`
	AuthorID      pgtype.UUID      `json:"author_id"`
	UpVoted       int32            `json:"up_voted"`
	DownVoted     int32            `json:"down_voted"`
	CommentsCount int32            `json:"comments_count"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	AuthorEmail   pgtype.Text      `json:"author_email"`
	AuthorName    pgtype.Text      `json:"author_name"`
	AuthorImage   pgtype.Text      `json:"author_image"`
	Priority      int32            `json:"priority"`
}

func (q *Queries) GetTopFollowedPosts(ctx context.Context, arg GetTopFollowedPostsParams) ([]GetTopFollowedPostsRow, error) {
	rows, err := q.db.Query(ctx, getTopFollowedPosts, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopFollowedPostsRow{}
	for rows.Next() {
		var i GetTopFollowedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.UpVoted,
			&i.DownVoted,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorEmail,
			&i.AuthorName,
			&i.AuthorImage,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
